导航头TopMenu
1.定制Menu组件，实现头部导航栏TopMenu
遇到问题：
    menu中元素的响应式布局无法实现
        通过<div style={{ display: 'flex', alignItems: 'center' }}>包裹Menu实现响应式布局

2.定制搜索框组件SearchInput，被TopMenu调用


主页Main
1.使用Grid对主页main进行布局
遇到问题：
    一开始想通过Layout进行布局，发现灵活性不够
        干脆直接全部用Row进行布局

2.在Row的顶端用span为24的Col调用TopMenu

3.main中创建span为20的主Col

4.定制幻灯片Carousel组件，被主col调用

5.定制main所用的视频卡片MainVideoCard，用Flex排列成MainVideoFlex，被主col调用
遇到问题：
    Card中的默认布局不好调整布局
        干脆全部用Flex完成布局
    不知道怎么在图片的右下角显示播放量等数据
        通过设置图片的父标签的style的position为relative，设置与图片平级的数据标签的position为absolute实现浮在图片右下角


视频页Video
1.video中创建span为16的主col，span为5的副col

2.定制video所用的视频卡片SideVideoCard，用Flex排列成SideVideoFlex，被副col调用

3.定制上传者卡片UploaderCard，被副col调用

4.定制视频播放器VideoPlayer，被主col调用
遇到问题：
    不知道怎么保持视频的长宽比，使得在响应式布局时长宽比不变
        给vidio标签设置style={{aspectRatio: '16/9'}}

5.定制评论卡片CommentCard，其下可调用子评论卡片SubCommentCard

6.定制评论区CommentFlex，调用CommentCard，被主col调用
遇到问题：
    由谁来判断是否调用SubCommentCard
        由CommentCard自己判断，是否有SubCommentCard的信息与CommentCard自己关联，在请求自己的信息时就可拿到


登录对话框LoginModal
1.定制登录对话框LoginModal，当点击时弹出对话框
遇到问题：
    我以为表单提交时只能在当前url提交，如果为了使后端能接收到统一url提交出的数据，这显然无法实现
        考虑通过二级路由在表单处通过统一的二级路由发出请求，但发现二级路由是拼接在一级路由之后的，这还是无法实现统一url
        后来才知道统一的url与发送方没有任何关系，只要接收方是统一的url就可以了

2.定制登录表单LoginForm，注册表单RegisterForm，被LoginModal调用，通过LoginModal中Tabs选择显示哪个表单
遇到问题：
    无限渲染报错
        我看见useState的setValue都要在jsx外的函数中被封装好，jsx中的click再调用封装函数，为什么不直接在click中用setValue
        原来是因为这样做会导致无限循环
    在实现子组件切换功能时，选择Tabs还是Segmented
        一开始通过Segmented绑定State，然后判断State的值选择对应组件进行渲染
        后来发现要自己多写一个判断State的函数，并且竖着的Segment和他右边的组件还要再进行一次布局
        干脆直接使用Tabs完成切换显示和布局


个人页User
1.定制个人页user，通过Tabs调用子组件

2.定制消息组件UserMessage，通过Tabs调用子组件

3.定制消息中的对话组件UserMessageChat，通过Tabs实现选择不同的对话

4.定制对话组件Chat，实现对话功能，可被UserMessageChat调用
遇到问题：
    怎么实现对话系统
        通过State存放对话记录
        设置List的dataSource为State，通过List的renderItem逐条得到State中每一条对话，并渲染为jsx
        通过对话的sender属性判断对话该渲染在左边还是右边
        给输入框绑定useRef，点击发送按钮时获取Ref的value并将数据添加进State引发List的再次渲染

5.定制三个通知组件UserMessageAted、UserMessagePraised、UserMessageSystem

6.定制三个通知组件中每一条消息对应的Card组件，被通知组件中的Flex调用

7.定制收藏组件UserFavourite，通过Tabs区分视频、文章、动态的收藏，并根据对应的类型调用对应参数的UserFacouriteCard

8.定制历史组件UserHitory，类似UserFavourite组件

9.定制稿件组件UserVideo，调用SearchSortDropdown，调用UserVideoFlex，实现查看视频Card并可选排序


动态页Focus
1.定制动态页focus，包含一个表单和一个Tabs
遇到问题：
    antd的Form中如何提交表单
        Form中需要有htmlType="submit"的Button进行提交

2.定制表单中的文本上传功能UploadText

3.定制表单中的图片列表上传功能UploadFileList
遇到问题
    Upload组件的使用
        设置listType="picture-card"，fileList={fileList}实现多图显示
        Upload组件中包含一个按钮，当按钮被点击后，生成一个file对象，并将file.status设置为'uploading'
        file对象为{本次添加的图片file对象,Upload中所有的file对象组成的数组fileList}
        将file对象上传到action指定的url
        接收到服务器的响应数据后，响应数据会被添加到file对象中的response属性中，并将并将file.status设置为'done'
        onChange绑定的函数会在file.status发生变化时触发，并传入file对象作为函数的参数
        通过在onChange绑定的函数中设置fileList的State实现动态更新Upload的fileList
    Upload中的图片的预览问题
        onPreview为点击图片上的预览图标时执行的操作，传入file对象作为参数
        通过onPreview来控制一个Image的preview的visible来直接展示预览后的图片
        当通过给visible传入State来控制其状态时，Image会成为受控组件，此时preview中的所有属性都会被覆盖
        此时preview中原本的点击蒙层实现关闭预览的功能也会被覆盖，需要设置onVisibleChange以实现该功能
        React中实现控制html标签的方式，不是通过DOM，而是通过useState控制标签的display来实现

4.定制切换不同用户动态的FocusTabs

5.定制展示动态的卡片FocusUploaderCard，可判断动态是文本类型FocusUploaderText、还是视频类型FocusUploaderVideo来切换展示

6.定制动态展示栏FocusUploaderFlex，调用FocusUploaderCard，被FocusTabs调用


专栏页Essay
1.定制专栏页essay，调用TopMenu，调用CommentFlex


搜索页Search
1.调用SearchInput

2.定制切换不同搜索类型的SearchTypeTabs

3.定制切换排序类型的SearchSortDropdown，被SearchTypeTabs调用

4.定制搜索视频展示栏SearchVideoFlex，调用MainVideoCard，被SearchTypeTabs调用
遇到问题：
    让SearchVideoFlex得到排序信息，以根据排序信息对MainVideoCard进行不同的排序
        在SearchTypeTabs中给SearchSortDropdown传入一个setState，以得到排序类型sort
        在SearchTypeTabs中给SearchVideoFlex传入sort，使其得到排序类型
        也可以通过ValueContext.Provider实现复杂的跨组件通信
        也可以通过Redux进行跨组件的状态管理

5.定制搜索动态展示栏SearchFocusFlex，调用FocusUploaderCardApp，被SearchTypeTabs调用
遇到问题：
    设置Flex中的元素宽度
        通过<Flex><FocusUploaderCardApp flex={'0 1 400px'} /></Flex>设置FocusUploaderCardApp的flex属性来实现
        或将FocusUploaderCardApp的布局全部换成Grid，通过<Row><Col span={24}><FocusUploaderCardApp/></Col></Row>来实现
    响应式布局
        纯css中通过媒体查询动态变更style属性值来实现响应式
        Flex封装了媒体查询，自动进行响应式布局
        Grid也可以自动进行响应式布局，也能通过断点手动设置响应式布局

6.定制搜索专栏展示栏SearchEssayFlex，调用EssayCard，被SearchTypeTabs调用

7.定制搜索用户展示栏SearchUserFlex，调用UploaderCard，被SearchTypeTabs调用

8.定制搜索标签展示栏SearchTagFlex，调用TagCard，被SearchTypeTabs调用
遇到问题：
    当点击导航头中的标签按钮时，跳转到搜索页并以SearchTagFlex为SearchTypeTabs的默认展示
        当跳转时携带get数据，在search页通过useSearchParams判断是否有数据并得到参数，
        根据参数设置Tabs的activeKey属性值


标签页Tag
1.定制标签页Tag，调用TopMenu，调用CommentFlex


标签栏TagRow
1.定制标签气泡卡片TagPopover，调用TagCard

2.定制标签栏TagRow，调用TagPopover
遇到问题；
    第一行只展示最多指定数量的TagPopover，隐藏多出的部分，并通过右侧的按钮设置多出部分在当前行下方的展示与再次隐藏
        按钮控制展示状态，状态管理控制多出的TagPopover的展示，由Row本身实现自动换行


上传页Upload
1.定制上传页upload，通过Tabs调用UploadVideo和UploadEssay，实现视频上传和文章上传的切换

2.定制视频上传页UploadVideo，实现视频上传，封面选取，封面上传，简介上传的功能，调用UploadText，后通过Form双传
遇到问题：
    上传视频的预览
        点击预览时显示对话框Modal，Modal中包含上传的video的src
        关闭预览即为关闭Modal
    实现截取视频中某一画面作为封面的功能
        使用canvas标签，将video的画面绘制下来，然后导出为base64的jpeg
        将该jpeg作为file文件的thumbUrl属性，实现在略缩图中显示封面
        将该jpeg作为video文件的poster属性，实现在预览时看到封面
        控制canvas执行的button在Modal中，但在预览时不显示，display为none，只在点击截取按钮后设置display为inline-flex
    实现单独上传封面的功能
        单独用一个Upload接收上传的图片，上传成功后将该图片设置为file文件的thumbUrl属性，实现预览显示封面

3.定制文章上传页UploadEssay，调用UploadText，通过Form上传


部署
部署在github pages
    npm install gh-pages --save-dev
    package.json中添加 "homepage": "https://2772780896.github.io/项目名"
    package.json的scripts中添加 "predeploy": "npm run build", "deploy": "gh-pages -d build --repo https://github.com/2772780896/项目名.git"
    运行 npm run build 将项目打包到build文件夹下
    运行 npm run deploy 用build文件夹中的内容生成 gh-pages 分支，并将该分支推送到github上
    github pages 绑定该分支
路由实现
    当用creatBrowserRouter实现路由时，
        当访问 https://2772780896.github.io/项目名 时，github pages会去查看根目录下的index.html
            当根index.html执行时，react应用会启动，会检查当前url，并通过路由返回对应的页面
        当访问 https://2772780896.github.io/项目名/子页面 时，github pages会去寻找 子页面.html 
            由于react为单页面应用，并没有对应页面，所以github pages会返回自带的404.html
            通过 "build": "craco build && copy build\\index.html build\\404.html" 用index.html生成一个404.html
            当build文件夹中存在自建的404.html时，当404响应时，github pages会返回这个页面，
            其中的react应用会再次启动，并根据对应的url返回对应的路由，实现路由跳转
            通过在 createBrowserRouter([],{basename:'/项目名'}) 设置路由时的根路径，实现跳转到 /子页面 时，为跳转到 /项目名/子页面
        当在已经启动的react应用中通过Link标签访问 https://2772780896.github.io/项目名/子页面 时，
            react会更新url为 2772780896.github.io/项目名/子页面 ，然后通过Browser路由根据路径渲染对应组件，而不是发送服务器请求
    当用creatHashRouter实现路由时，
        将createBrowserRouter改为creatHashRouter
        当使用hash路由时，即在已经启动的react应用中通过Link标签访问 https://2772780896.github.io/项目名/#/子页面 时，
            不会再次向github pages服务器发送请求，而是修改 window.location.hash 的值，并用hash路由捕获这个值，并渲染对应的组件
        当不在react应用中访问 https://2772780896.github.io/项目名/#/子页面 时，
            github pages不会收到#之后的信息，所以还是会返回index.html，启动react应用，react再根据hash值进行路由


Carousel中图片的网络请求与数据渲染
遇到问题:
    async/await机制
        async函数一旦执行，就会返回一个状态为pending的promise对象
        当async函数中运行到await语句时，等待await运行结束，并同时运行async函数外的语句
        所以通过async函数返回await执行的结果，并在函数外通过赋值得到这个结果是不合理的
        因为当赋值发生时，async函数并没有得到返回值，即使得到返回值，也会是一个promise对象
        所以想获取await语句运行得到的值，需要在await下通过useState设置值
        还需要将async放在useEffect中运行，并且依赖项为 [] ，使得函数只会在渲染完成后运行一次
        否则每次渲染完成后等待await语句执行完成后，下方的useState运行，触发整个组件重新渲染，导致无限循环
     mock实现
        在src下创建mock文件夹，创建index.js，实现mock拦截携带了参数的url请求，并获取参数，设置响应
        在react的入口文件，根index.js中 import './mock/index.js' 以启动mock
1. 在utils的request.js中封装axios请求
2. 在apis的main的getCarouselPicture.js中设置请求的url和携带的参数，并异步执行
3. 在hooks的main的useCarouselPicture.js中设置state储存数据，在useEffect中异步调用getCarouselPicture，
    获取响应中实际需要的数据，设置state为对应数据，设置依赖项为getCarouselPicture的参数，返回state
4. 在pages的Main.js中调用useCarouselPicture并传入参数，将结果传给Carsousel
5. 在components的common的Carsousel.js中获取数据url组成的列表，将其通过map映射为对应Link标签包裹的img标签，
    在Carousel标签中调用这个Link标签列表
遇到问题：
    运行流程
        react启动，启动mock，useCarouselPicture中请求发出，此时请求为异步执行，所以setState还没有发生，
        外部使用useState时设置的值作为数据，继续向下执行，继续渲染Main组件
        当useCarouselPicture中请求完成，setState设置数据，使Main组件刷新，以新state再次渲染
        若没有使用useEffect，会导致每次更新时都再次发出请求，并再次setState，导致无限循环
